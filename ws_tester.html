<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WS /audio — тест микрофона</title>
  <style>
    body{font-family:system-ui,Arial;max-width:760px;margin:24px auto}
    pre{background:#111;color:#0f0;padding:12px;height:280px;overflow:auto}
    button{margin-right:8px}
  </style>
</head>
<body>
  <h2>WS /audio — тест микрофона</h2>
  <button id="start">Start</button>
  <button id="stop" disabled>Stop</button>
  <pre id="log"></pre>

<script>
const logEl = document.getElementById('log');
const log = m => { logEl.textContent += m + "\n"; logEl.scrollTop = logEl.scrollHeight; };

let ws, audioCtx, scriptNode, source, stream;

function floatTo16BitPCM(input) {
  const buf = new ArrayBuffer(input.length * 2);
  const view = new DataView(buf);
  for (let i=0, off=0; i<input.length; i++, off+=2) {
    let s = Math.max(-1, Math.min(1, input[i]));
    view.setInt16(off, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  return new Uint8Array(buf);
}
function downsampleTo16k(inputBuffer, inputSampleRate) {
  if (inputSampleRate === 16000) return inputBuffer;
  const ratio = inputSampleRate / 16000;
  const outLen = Math.round(inputBuffer.length / ratio);
  const out = new Float32Array(outLen);
  let o = 0, i = 0;
  while (o < outLen) {
    const ni = Math.round((o + 1) * ratio);
    let sum = 0, cnt = 0;
    for (; i < ni && i < inputBuffer.length; i++) { sum += inputBuffer[i]; cnt++; }
    out[o++] = sum / (cnt || 1);
  }
  return out;
}

document.getElementById('start').onclick = async () => {
  try { stream = await navigator.mediaDevices.getUserMedia({ audio: true }); }
  catch(e){ log('❌ Разреши доступ к микрофону'); return; }

  ws = new WebSocket('ws://127.0.0.1:8000/audio');
  ws.onopen = () => {
    log('WS: open');
    ws.send(JSON.stringify({event:'start', sample_rate:16000, lang:'ru'}));
    document.getElementById('start').disabled = true;
    document.getElementById('stop').disabled = false;
  };
  ws.onmessage = ev => {
      try {
        const data = JSON.parse(ev.data);
        log('⬇ ' + JSON.stringify(data, null, 2));
      } catch {
        log('⬇ ' + ev.data);
      }
    };

  ws.onerror = e => log('WS error');
  ws.onclose = () => log('WS: closed');

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const inSR = audioCtx.sampleRate;
  source = audioCtx.createMediaStreamSource(stream);
  scriptNode = audioCtx.createScriptProcessor(4096, 1, 1);
  let sent = 0, t0 = performance.now();
  scriptNode.onaudioprocess = e => {
    const input = e.inputBuffer.getChannelData(0);
    const down = downsampleTo16k(input, inSR);
    const pcm16 = floatTo16BitPCM(down);
    if (ws && ws.readyState === 1) { ws.send(pcm16); sent += pcm16.byteLength; }
    const dt = performance.now() - t0;
    if (dt > 1000) { log(`↑ ${Math.round(sent/1024)} KB/s (sr=${inSR} -> 16000)`); sent = 0; t0 = performance.now(); }
  };
  source.connect(scriptNode);
  scriptNode.connect(audioCtx.destination);
};

document.getElementById('stop').onclick = () => {
  if (ws && ws.readyState === 1) ws.send(JSON.stringify({event:'stop'}));
  if (scriptNode) scriptNode.disconnect();
  if (source) source.disconnect();
  if (audioCtx) audioCtx.close();
  if (stream) stream.getTracks().forEach(t => t.stop());
  document.getElementById('start').disabled = false;
  document.getElementById('stop').disabled = true;
  log('⏹️ stop');
};
</script>
</body>
</html>
