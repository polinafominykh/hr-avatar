<!doctype html>
<meta charset="utf-8" />
<title>WS Audio Tester</title>
<style>
  body { font-family: system-ui, sans-serif; max-width: 720px; margin: 40px auto; }
  button { padding: 10px 16px; margin-right: 8px; }
  #log { white-space: pre-wrap; background:#111; color:#0f0; padding:12px; height: 260px; overflow:auto; }
</style>
<h1>WebSocket Audio Tester → ws://127.0.0.1:8001/audio</h1>
<p>
  <button id="start">Start</button>
  <button id="stop" disabled>Stop</button>
</p>

<h3>Расшифровка</h3>
<div id="transcript" style="border:1px solid #ccc; padding:10px; min-height:100px;"></div>
<button id="clear">Очистить</button>
<hr>

<pre id="log"></pre>
<script>
const log = (...a) => { const l = document.getElementById('log'); l.textContent += a.join(' ') + "\n"; l.scrollTop = l.scrollHeight; };
const addText = (t) => {
  const box = document.getElementById('transcript');
  const p = document.createElement('p');
  p.textContent = t;
  box.appendChild(p);
  box.scrollTop = box.scrollHeight;
};
document.getElementById('clear').onclick = () => {
  document.getElementById('transcript').innerHTML = '';
};

let ws, audioCtx, mediaStream, source, processor;
let buf16k = [];
const CHUNK_MS = 320;

function floatTo16PCM(float32Array) {
  const out = new Int16Array(float32Array.length);
  for (let i = 0; i < float32Array.length; i++) {
    let s = Math.max(-1, Math.min(1, float32Array[i]));
    out[i] = (s < 0 ? s * 0x8000 : s * 0x7fff) | 0;
  }
  return out.buffer;
}

// простейший даунсемплер из любой частоты в 16k
function downsampleTo16k(input, inputSampleRate) {
  if (inputSampleRate === 16000) return input;
  const ratio = inputSampleRate / 16000;
  const newLen = Math.round(input.length / ratio);
  const result = new Float32Array(newLen);
  for (let i = 0; i < newLen; i++) {
    const start = Math.floor(i * ratio);
    const end = Math.floor((i + 1) * ratio);
    let sum = 0, count = 0;
    for (let j = start; j < end && j < input.length; j++) { sum += input[j]; count++; }
    result[i] = count ? sum / count : input[start];
  }
  return result;
}

document.getElementById('start').onclick = async () => {
  try {
    ws = new WebSocket("ws://127.0.0.1:8001/audio");
    ws.onopen = () => {
      log("WS open");
      ws.send(JSON.stringify({event:"start", sample_rate:16000, lang:"ru"}));
    };

    // <<< ВАЖНО: новый обработчик сообщений >>>
    ws.onmessage = (ev) => {
      try {
        const obj = JSON.parse(ev.data);
        if (obj.event === 'final' && obj.text) {
          addText(obj.text);               // выводим распознанный текст в блок "Расшифровка"
        } else {
          log("WS ⇦", ev.data);            // служебные сообщения — в лог
        }
      } catch {
        log("WS ⇦", ev.data);              // если прилетела не-JSON строка
      }
    };

    ws.onclose = () => { log("WS closed"); };
    ws.onerror = (e) => { log("WS error", e.message || e); };

    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true, channelCount: 1, sampleRate: 16000 }
    });

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    source = audioCtx.createMediaStreamSource(mediaStream);
    processor = audioCtx.createScriptProcessor(2048, 1, 1);

    const inputRate = audioCtx.sampleRate; // обычно 48000
    processor.onaudioprocess = (e) => {
      const ch0 = e.inputBuffer.getChannelData(0);
      const ds = downsampleTo16k(ch0, inputRate);  // float32 16kHz
      buf16k.push(ds);
    };

    source.connect(processor);
    // делаем «тихий» выход, чтобы не было эха
    const silent = audioCtx.createGain(); silent.gain.value = 0;
    processor.connect(silent); silent.connect(audioCtx.destination);

    // каждые 320мс отправляем бинарный фрейм
    processor._timer = setInterval(() => {
      if (!buf16k.length || ws.readyState !== 1) return;
      const totalLen = buf16k.reduce((s,a)=>s+a.length,0);
      const joined = new Float32Array(totalLen);
      let offset = 0;
      for (const a of buf16k) { joined.set(a, offset); offset += a.length; }
      buf16k = [];
      // без усиления — сервер сам подстроит
      for (let i = 0; i < joined.length; i++) {
        if (joined[i] > 1) joined[i] = 1;
        if (joined[i] < -1) joined[i] = -1;
      }
      const pcm16 = floatTo16PCM(joined);
      ws.send(pcm16);
      log("WS ⇨ bytes", (pcm16.byteLength || pcm16.size || 0) + "B");
    }, CHUNK_MS);

    document.getElementById('start').disabled = true;
    document.getElementById('stop').disabled = false;
    log("Mic started. Input SR:", inputRate);
  } catch (err) {
    log("ERROR:", err.message || err);
  }
};

document.getElementById('stop').onclick = async () => {
  try {
    ws && ws.readyState === 1 && ws.send(JSON.stringify({event:"stop"}));
    if (processor && processor._timer) clearInterval(processor._timer);
    if (processor) processor.disconnect();
    if (source) source.disconnect();
    if (audioCtx) await audioCtx.close();
    if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
    ws && ws.close();
    log("Stopped.");
  } catch (e) { log("Stop error", e.message || e); }
  document.getElementById('start').disabled = false;
  document.getElementById('stop').disabled = true;
};
</script>

